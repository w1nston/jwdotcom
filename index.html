<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans|Montserrat"
          rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/css/materialize.min.css"
          rel="stylesheet">
    <link href="public/assets/styles/jwdotcom.css" rel="stylesheet">
    <link href="vendor/assets/styles/tomorrow-night-blue.css"
          rel="stylesheet">
  </head>
  <body>
    <div class="row">
      <div class="col s12 m12 l12 right-align">
        <section class="menu-content">
          <img class="menu-content__logo" src="public/assets/images/jwlogo.svg">
        </section>
      </div>
    </div>
    <div class="row">
      <div class="col s12 m12 l8">
        <section class="main-content">
          <article class="main-content__article">
            <h1>Continuous Delivery Pipeline - Take one</h1>
            <p>
              So this is my attempt at creating a continuous delivery pipeline.
              First it seems like a good idea to just deliver something to a
              server manually to get a feel for what needs to be done,
              and what steps can be automated.
            </p>
            <h2>The project structure</h2>
            <p>
              The focus is on the delivery pipeline, not on the content. In other words, no worries
              about what library to chose, how to configure webpack, or what color to use on the
              headlines. It is actually really difficult to let go of all that. But need to move
              forward!
            </p>
            <p>
              So, the structure consists of an index.html file that actually is the page, as well as
              a public directory containing any assets. The assets for the time being are one simple
              stylesheet and a svg image.
            </p>
            <pre>
              <code>
                |-rootDirectory
                | |-public
                | | |-assets
                | | | |-images
                | | | | |-logo.svg
                | | | |-styles
                | | | | |-style.css
                | |-index.html
              </code>
            </pre>
            <p>
              The project is checked in at
              <a
                target="_blank"
                href="https://github.com/w1nston/jwdotcom"
              >Github</a>.
            </p>
            <h2>The server structure</h2>
            <p>
              The server is running on a virtual private server (VPS), setup with Ubuntu 14.04 LTS.
              Following the guides on
              <a
                target="_blank"
                href="https://www.linode.com/docs/security/securing-your-server"
              >Linode</a>, and in the home
              directory the project is cloned from Github. I then copied the index.html and the
              public directory to
              <pre>
                <code class="bash">
                  /srv/www/example.com/&ltdate&gt/
                </code>
              </pre>
            </p>
            <p>
              To serve the content I use
              <a
                target="_blank"
                href="https://nginx.org/en/"
              >nginx</a>, and am pointing the root location to
              <pre>
                <code class="bash">
                  /srv/www/example.com/latest
                </code>
              </pre>
              where the <i>latest</i>-directory is simply a symbolic link pointing to
              another
              sibling directory named with a date. This makes it easy to point to a new release
              once available.
            <pre>
              <code class="bash">
                20160810/
                20160917/
                latest -> 20160917/
              </code>
            </pre>
            </p>
            <h2>Reflections</h2>
            <p>
              I have a first version of a pipeline, maybe not much of a continuous delivery
              pipeline just yet, but lets see what we got.
            </p>
            <p>
              With this approach the pipeline looks like follows. I do a change in the source code,
              push it to the origin repository. Manually login to the VPS, pull the new changes,
              copy them to a new directory, and name it with the current date. Oh, wait! What about
              two or more releases during one day?
            </p>
            <p>
              I clearly need to figure out a better way to deal with release versions, duly noted.
              But lets move on...
            </p>
            <p>
              Once the files are copied over to the versioned release directory and we feel lucky.
              A new symlink needs to be created, and it should of course point to the most recent
              release version.
            </p>
            <p>
              So, a lot of manual steps, but that's what's to be expected since the goal was to
              just get anything working. It is easier to improve something than it is to create
              something perfect from the beginning.
            </p>
            <h2>Improvement points</h2>
            <p>
              So, what can be improved? Initially I see two points to improve: release versioning,
              and number of manual steps.
            </p>
            <h3>Release versioning</h3>
            <p>
              Okay, so just a date won't cut it. Lets play a little with something similar to
              <a
                target="_blank"
                href="http://semver.org/">
                semver
              </a>. The date part is not totally useless, but it needs a little more. Another type
              of sequence to distinguish if it is the first, or second release of the day etc. Lets
              play with the following format.
            </p>
            <pre>
              <code class="bash">
                &ltyear&gt.&ltmonth&gt.&ltday&gt.&ltversion&gt.&ltbugfix version&gt

                // E.g.

                2016.09.18.1.0
              </code>
            </pre>
            <p>
              Right now I can't really think of anything as to why not to try this versioning, so
              I'll just go ahead and evaluate it for now.
            </p>
            <h3>Number of manual steps</h3>
            <p>
              From the git push command there shouldn't be too many steps before a new release
              can be tested, and finally deployed. With this pipeline there are at least five steps
              before a new release sees the light of day.
            </p>
            <p>
              One step to login to the VPS, one step to pull the updates from Github, one step to
              copy the files to a new versioned release directory, one step to redirect the
              <i>latest</i>-symlink, and lastly, one step to reload the nginx-server.
            </p>
            <p>
              So, what to do? I suppose it's time to try som shell scripting. Now what would I need
              in form of a shell script then? Let's see, without changing anything but just automate
              all steps a script could consist of something like the following.
            </p>
            <pre>
              <code class="bash">
                #!/usr/bin/env bash

                # 1) Fetch latest source code from Github, perhaps by listening on git hooks
                ...

                # 2) Copy just the needed files to /srv/www/example.com/2016.09.18.1.0/
                ...

                # 3) Symlink the directory "latest" to the most recent release directory
                ...

                # 4) Restart nginx
                ...
              </code>
            </pre>
            <p>
              Although, I found
              <a
                target="_blank"
                href="https://serversforhackers.com/video/automating-deployment-from-github"
              >something interesting</a> that got me thinking about a different structure. At first
              I've considered that I don't want to expose the entire repository from Github. Now
              I start to think that maybe it's cleaner just to clone a new repository on every
              release, and do the build step with the script as well.
            </p>
            <p>
              I am thinking that I'll try out the following instead, and simply skip the copying
              step.
            </p>
            <pre>
              <code class="bash">
                /srv/www/example.com/releases/2016.09.17.1.0
                /srv/www/example.com/releases/2016.09.18.1.0
                /srv/www/example.com/latest -> /srv/www/example.com/releases/2016.09.18.1.0
              </code>
            </pre>
          </article>
        </section>
      </div>
    </div>
    <footer>
      <script
        src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>
    </footer>
  </body>
</html>
